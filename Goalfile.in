# Goalfile
# Copyright (C) 2019 Richard W.M. Jones
# Copyright (C) 2019 Red Hat Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

include "ocaml.gl"

let subdirs = [ "m4", "src", "stdlib", "docs", "man", "tests" ]

goal all = : "Goalfile", tool, documentation;

"Goalfile": "Goalfile.in", "config.status" {
    ./config.status %@
}
"src/config.ml" : "src/config.ml.in", "config.status" {
    ./config.status %@
}

goal clean = : wrap ("clean-subdir", subdirs), clean-subdir ("."), clean-other

goal clean-subdir (dir) = {
    cd %dir
    rm -f *~
    rm -f *.cmi *.cmo *.cmx *.o
}

goal clean-other = {
    rm -f src/parser.ml src/parser.mli src/lexer.ml src/parser.conflicts
    rm -f man/*.1 man/*.5
    rm -f tests/*.log

    # We don't delete src/goals because it is required to do builds.
    # If you want to really delete it, use the maintainer-clean rule.
}

goal maintainer-clean = : clean {
    rm -f src/goals
}

#----------------------------------------------------------------------
# Build the goals tool itself.

let CC = "@CC@"
let OCAMLLIB = "@OCAMLLIB@"
let MENHIR = "@MENHIR@"
let OCAMLDEP = "@OCAMLDEP@"
let OCAMLFIND = "@OCAMLFIND@"
let OCAMLLEX = "@OCAMLLEX@"
let CFLAGS = join (split ("@CFLAGS@"), ["-I%OCAMLLIB", "-I."])
let OCAMLFLAGS = split ("@OCAMLFLAGS@")
let OCAMLPACKAGES = join (split ("@OCAMLPACKAGES@"), ["-I", "src"])

let objects = [
    # These must be in dependency order.
    "src/config.cmx",
    "src/utils-c.o",
    "src/utils.cmx",
    "src/cmdline.cmx",
    "src/jobs.cmx",
    "src/ast.cmx",
    "src/parser.cmx",
    "src/lexer.cmx",
    "src/parse.cmx",
    "src/eval.cmx",
    "src/deps.cmx",
    "src/run.cmx",
    "src/main.cmx"
]

goal tool = : ocaml_link ("src/goals", objects) ;

# C code.
"src/utils-c.o" : "src/utils-c.c" {
    %CC %CFLAGS -c %< -o %@
}

# Parser.
"src/parser.mli", "src/parser.ml" : "src/parser.mly" {
    %MENHIR --explain %<
    # Hack required to break circular dependencies.
    echo 'val lexer_read : (Lexing.lexbuf -> token) option ref' >> src/parser.mli
    echo 'val eval_substitute : (Ast.env -> Ast.loc -> Ast.substs -> string) option ref' >> src/parser.mli
}

"src/lexer.ml" : "src/lexer.mll" {
    %OCAMLLEX %<
}

# XXX Goalfile itself depends on this and we should probably have a
# way to reevaluate it.
# XXX Atomic output.
goal depend =
"src/.depend" : wildcard ("src/*.ml"), wildcard ("src/*.mli") {
    rm -f %@ %@-t
    # Like many existing tools, ocamldep produces make-compatible
    # output which doesn't work directly in goals.
    %OCAMLDEP -all -one-line -I src %< |
        sed 's|[./[:alnum:]]\+|"&"|g' |
        sed 's|" "|", "|g' |
        sed 's|.*|& ;|' > %@-t
    mv %@-t %@
}

-include "src/.depend";

#----------------------------------------------------------------------
# Documentation.

let POD2MAN = "@POD2MAN@"

goal documentation = : pod2man ("goals", "1"),
                       pod2man ("Goalfile", "5")

goal pod2man (page, section) =
"man/%page.%section" : "docs/%page.pod" {
    rm -f %@ %@-t
    mkdir -p man
    %POD2MAN \
        -u \
        -c "goals" \
        --release "@PACKAGE_NAME@-@PACKAGE_VERSION@" \
        --section %section %< > %@-t
    mv %@-t %@
}

#----------------------------------------------------------------------
# Tests.

let tests = wrap ("test", wildcard ("tests/*.sh"))

goal check () = : tests

goal test (name) = @{
    t=`basename %name`
    cd tests
    if ../run ./$t > $t.log 2>&1; then
        start_green
        echo -n "PASS: "
        end_colour
        echo $t
    else
        start_red
        echo -n "FAIL: "
        end_colour
        echo $t
        exit 1
    fi
}
